#ifndef _RUA_EXEC_CONT_WIN32_HPP
#define _RUA_EXEC_CONT_WIN32_HPP

#include "../gnc/any_ptr.hpp"
#include "../gnc/any_word.hpp"
#include "../mem/protect.hpp"

#include "../macros.hpp"

#include <cstdint>
#include <initializer_list>
#include <cassert>

namespace rua {
	namespace exec {
		template <typename CodeBytes>
		any_ptr code_init(CodeBytes &&cb) {
			mem::protect(&cb, sizeof(cb), mem::protect_read | mem::protect_exec);
			return &cb;
		}

		// Reference from https://github.com/skywind3000/collection/tree/master/context

		static const uint8_t _cont_push_code[]{
			#ifdef RUA_AMD64
				#ifdef RUA_WIN64_FASTCALL
					0x48, 0x89, 0x51, 0x18, 0x48, 0x89, 0x01, 0x48, 0x89, 0x59, 0x08, 0x48, 0x89, 0x49, 0x10,
					0x48, 0x89, 0x71, 0x20, 0x48, 0x89, 0x79, 0x28, 0x48, 0x89, 0x61, 0x30, 0x48, 0x89, 0x69,
					0x38, 0x48, 0x8B, 0x14, 0x24, 0x48, 0x89, 0x51, 0x40, 0x9C, 0x5A, 0x48, 0x89, 0x51, 0x48,
					0x4C, 0x89, 0x41, 0x50, 0x4C, 0x89, 0x49, 0x58, 0x4C, 0x89, 0x51, 0x60, 0x4C, 0x89, 0x59,
					0x68, 0x4C, 0x89, 0x61, 0x70, 0x4C, 0x89, 0x69, 0x78, 0x4C, 0x89, 0xB1, 0x80, 0x00, 0x00,
					0x00, 0x4C, 0x89, 0xB9, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x51, 0x18, 0x0F, 0xAE, 0x99,
					0x90, 0x00, 0x00, 0x00, 0xD9, 0xB1, 0x98, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC0, 0x01, 0x00,
					0x00, 0x00, 0xC3
				#else
					0x48, 0x89, 0x57, 0x18, 0x48, 0x89, 0x07, 0x48, 0x89, 0x5F, 0x08, 0x48, 0x89, 0x4F, 0x10,
					0x48, 0x89, 0x77, 0x20, 0x48, 0x89, 0x7F, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x08, 0x48, 0x89,
					0x57, 0x30, 0x48, 0x89, 0x6F, 0x38, 0x48, 0x8B, 0x14, 0x24, 0x48, 0x89, 0x57, 0x40, 0x9C,
					0x5A, 0x48, 0x89, 0x57, 0x48, 0x4C, 0x89, 0x47, 0x50, 0x4C, 0x89, 0x4F, 0x58, 0x4C, 0x89,
					0x57, 0x60, 0x4C, 0x89, 0x5F, 0x68, 0x4C, 0x89, 0x67, 0x70, 0x4C, 0x89, 0x6F, 0x78, 0x4C,
					0x89, 0xB7, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xBF, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B,
					0x57, 0x18, 0x0F, 0xAE, 0x9F, 0x90, 0x00, 0x00, 0x00, 0xD9, 0xB7, 0x98, 0x00, 0x00, 0x00,
					0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xC3
				#endif
			#elif defined(RUA_I386)
			#endif
		};

		static bool (*_cont_push)(any_ptr) = code_init(_cont_push_code);

		static const uint8_t _cont_pop_code[]{
			#ifdef RUA_AMD64
				#ifdef RUA_WIN64_FASTCALL
					0x48, 0x8B, 0x59, 0x08, 0x48, 0x8B, 0x71, 0x20, 0x48, 0x8B, 0x79, 0x28, 0x48, 0x8B, 0x61,
					0x30, 0x48, 0x8B, 0x69, 0x38, 0x48, 0x8B, 0x51, 0x40, 0x48, 0x89, 0x14, 0x24, 0x48, 0x8B,
					0x51, 0x48, 0x52, 0x9D, 0x4C, 0x8B, 0x41, 0x50, 0x4C, 0x8B, 0x49, 0x58, 0x4C, 0x8B, 0x51,
					0x60, 0x4C, 0x8B, 0x59, 0x68, 0x4C, 0x8B, 0x61, 0x70, 0x4C, 0x8B, 0x69, 0x78, 0x4C, 0x8B,
					0xB1, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xB9, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x51,
					0x18, 0x0F, 0xAE, 0x91, 0x90, 0x00, 0x00, 0x00, 0xD9, 0xA1, 0x98, 0x00, 0x00, 0x00, 0x48,
					0x8B, 0x49, 0x10, 0x48, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC3
				#else
					0x48, 0x8B, 0x5F, 0x08, 0x48, 0x8B, 0x4F, 0x10, 0x48, 0x8B, 0x77, 0x20, 0x48, 0x8B, 0x67,
					0x30, 0x48, 0x8B, 0x6F, 0x38, 0x48, 0x8B, 0x57, 0x40, 0x52, 0x48, 0x8B, 0x57, 0x48, 0x52,
					0x9D, 0x4C, 0x8B, 0x47, 0x50, 0x4C, 0x8B, 0x4F, 0x58, 0x4C, 0x8B, 0x57, 0x60, 0x4C, 0x8B,
					0x5F, 0x68, 0x4C, 0x8B, 0x67, 0x70, 0x4C, 0x8B, 0x6F, 0x78, 0x4C, 0x8B, 0xB7, 0x80, 0x00,
					0x00, 0x00, 0x4C, 0x8B, 0xBF, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x57, 0x18, 0x0F, 0xAE,
					0x97, 0x90, 0x00, 0x00, 0x00, 0xD9, 0xA7, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x7F, 0x28,
					0x48, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC3
				#endif
			#elif defined(RUA_I386)
			#endif
		};

		static bool (*_cont_pop)(any_ptr) = code_init(_cont_pop_code);

		class cont {
			public:
				bool push() {
					return _cont_push(this);
				}

				void pop() const {
					_cont_pop(this);
				}

				void push_and_pop(const cont &pre_pop) {
					if (push()) {
						pre_pop.pop();
					}
				}

				void swap() {
					auto old = *this;
					if (push()) {
						old.pop();
					}
				}

				#ifdef RUA_AMD64
					void remake(void (*func)(any_word), any_word func_param, any_ptr stack, size_t stack_size) {
						rsp = (stack + stack_size - 1).value();
						rsp = rsp - (rsp % 8) - 8;

						*reinterpret_cast<uint64_t *>(rsp) = 0;

						#ifdef RUA_WIN64_FASTCALL
							rcx = func_param;
						#else
							rdi = func_param;
						#endif

						rip = reinterpret_cast<uint64_t>(func);
					}
				#elif defined(RUA_I386)
					void remake(void (*func)(any_word), any_word func_param, any_ptr stack, size_t stack_size) {
						esp = (stack + stack_size - 1).value();
						esp = esp - (esp % 8) - 8;
						*reinterpret_cast<uint64_t *>(esp) = 0;
						reinterpret_cast<uint64_t *>(esp)[1] = func_param;
						eip = reinterpret_cast<uint64_t>(func);
					}
				#endif

				////////////////////////////////////////////////////////////////

				#ifdef RUA_AMD64
					uint64_t rax;		// 0
					uint64_t rbx;		// 8
					uint64_t rcx;		// 16
					uint64_t rdx;		// 24
					uint64_t rsi;		// 32
					uint64_t rdi;		// 40
					uint64_t rsp;		// 48
					uint64_t rbp;		// 56
					uint64_t rip;		// 64
					uint64_t rflags;	// 72
					uint64_t r8;		// 80
					uint64_t r9;		// 88
					uint64_t r10;		// 96
					uint64_t r11;		// 104
					uint64_t r12;		// 112
					uint64_t r13;		// 120
					uint64_t r14;		// 128
					uint64_t r15;		// 136
					uint64_t mxcsr;		// 144
				#elif defined(RUA_I386)
					uint32_t eax;		// 0
					uint32_t ebx;		// 4
					uint32_t ecx;		// 8
					uint32_t edx;		// 12
					uint32_t esi;		// 16
					uint32_t edi;		// 20
					uint32_t esp;		// 24
					uint32_t ebp;		// 28
					uint32_t eip;		// 32
					uint32_t eflags;	// 36
					uint32_t mxcsr;		// 40
				#endif

				uint8_t fpregs[32];		// 44(32) / 152(64)
				uint32_t reserved[18];	// 76(32) / 186(64)
		};
	}
}

#endif
