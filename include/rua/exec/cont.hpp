#ifndef _RUA_EXEC_CONT_WIN32_HPP
#define _RUA_EXEC_CONT_WIN32_HPP

#include "../macros.hpp"

#if !defined(RUA_AMD64) && !defined(RUA_I386)
	#error rua::exec::cont: not supported this platform!
#endif

#include "../gnc/any_word.hpp"
#include "../mem/protect.hpp"

#include <cstdint>
#include <initializer_list>
#include <cassert>

namespace rua {
	namespace exec {
		template <typename CodeBytes>
		inline any_ptr code_init(CodeBytes &&cb) {
			mem::protect(&cb, sizeof(cb), mem::protect_read | mem::protect_exec);
			return &cb;
		}

		// Reference from https://github.com/skywind3000/collection/tree/master/context

		class cont {
			public:
				cont() = default;

				cont(std::nullptr_t) : cont() {}

				cont(void (*func)(any_word), any_word func_param, any_ptr stack, size_t stack_size) {
					remake(func, func_param, stack, stack_size);
				}

				bool push() {
					static const uint8_t code[]{
						#ifdef RUA_AMD64
							#ifdef _WIN64
								0x48, 0x89, 0x01, 0x48, 0x89, 0x59, 0x08, 0x48, 0x89, 0x49, 0x10, 0x48, 0x89, 0x51, 0x18,
								0x48, 0x89, 0x71, 0x20, 0x48, 0x89, 0x79, 0x28, 0x48, 0x89, 0x61, 0x30, 0x48, 0x89, 0x69,
								0x38, 0x48, 0x8B, 0x04, 0x24, 0x48, 0x89, 0x41, 0x40, 0x9C, 0x58, 0x48, 0x89, 0x41, 0x48,
								0x4C, 0x89, 0x41, 0x50, 0x4C, 0x89, 0x49, 0x58, 0x4C, 0x89, 0x51, 0x60, 0x4C, 0x89, 0x59,
								0x68, 0x4C, 0x89, 0x61, 0x70, 0x4C, 0x89, 0x69, 0x78, 0x4C, 0x89, 0xB1, 0x80, 0x00, 0x00,
								0x00, 0x4C, 0x89, 0xB9, 0x88, 0x00, 0x00, 0x00, 0x0F, 0xAE, 0x99, 0x90, 0x00, 0x00, 0x00,
								0xD9, 0xB1, 0x94, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC0, 0x30, 0x00, 0x00, 0x00, 0x65, 0x4C,
								0x8B, 0x10, 0x49, 0x8B, 0x42, 0x20, 0x48, 0x89, 0x81, 0xB0, 0x00, 0x00, 0x00, 0x49, 0x8B,
								0x82, 0x78, 0x14, 0x00, 0x00, 0x48, 0x89, 0x81, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x42,
								0x10, 0x48, 0x89, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x42, 0x08, 0x48, 0x89, 0x81,
								0xC8, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x02, 0x48, 0x89, 0x81, 0xD0, 0x00, 0x00, 0x00, 0x4C,
								0x8B, 0x51, 0x60, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xC3
							#else
								0x48, 0x89, 0x07, 0x48, 0x89, 0x5F, 0x08, 0x48, 0x89, 0x4F, 0x10, 0x48, 0x89, 0x57, 0x18,
								0x48, 0x89, 0x77, 0x20, 0x48, 0x89, 0x7F, 0x28, 0x48, 0x89, 0x67, 0x30, 0x48, 0x89, 0x6F,
								0x38, 0x48, 0x8B, 0x04, 0x24, 0x48, 0x89, 0x47, 0x40, 0x9C, 0x58, 0x48, 0x89, 0x47, 0x48,
								0x4C, 0x89, 0x47, 0x50, 0x4C, 0x89, 0x4F, 0x58, 0x4C, 0x89, 0x57, 0x60, 0x4C, 0x89, 0x5F,
								0x68, 0x4C, 0x89, 0x67, 0x70, 0x4C, 0x89, 0x6F, 0x78, 0x4C, 0x89, 0xB7, 0x80, 0x00, 0x00,
								0x00, 0x4C, 0x89, 0xBF, 0x88, 0x00, 0x00, 0x00, 0x0F, 0xAE, 0x9F, 0x90, 0x00, 0x00, 0x00,
								0xD9, 0xB7, 0x94, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xC3
							#endif
						#elif defined(RUA_I386)
							#ifdef _WIN32
								0x89, 0x44, 0x24, 0xFC, 0x8B, 0x44, 0x24, 0x04, 0x89, 0x58, 0x04, 0x8B, 0x5C, 0x24, 0xFC,
								0x89, 0x18, 0x89, 0x48, 0x08, 0x89, 0x50, 0x0C, 0x89, 0x70, 0x10, 0x89, 0x78, 0x14, 0x89,
								0x60, 0x18, 0x89, 0x68, 0x1C, 0x8B, 0x1C, 0x24, 0x89, 0x58, 0x20, 0x9C, 0x5B, 0x89, 0x58,
								0x24, 0x0F, 0xAE, 0x58, 0x28, 0xD9, 0x70, 0x2C, 0xBB, 0x18, 0x00, 0x00, 0x00, 0x64, 0x8B,
								0x0B, 0x8B, 0x59, 0x10, 0x89, 0x58, 0x48, 0x8B, 0x99, 0x0C, 0x0E, 0x00, 0x00, 0x89, 0x58,
								0x4C, 0x8B, 0x59, 0x08, 0x89, 0x58, 0x50, 0x8B, 0x59, 0x04, 0x89, 0x58, 0x54, 0x8B, 0x19,
								0x89, 0x58, 0x58, 0x8B, 0x48, 0x08, 0x8B, 0x58, 0x04, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xC3
							#else
								0x89, 0x44, 0x24, 0xFC, 0x8B, 0x44, 0x24, 0x04, 0x89, 0x58, 0x04, 0x8B, 0x5C, 0x24, 0xFC,
								0x89, 0x18, 0x89, 0x48, 0x08, 0x89, 0x50, 0x0C, 0x89, 0x70, 0x10, 0x89, 0x78, 0x14, 0x89,
								0x60, 0x18, 0x89, 0x68, 0x1C, 0x8B, 0x1C, 0x24, 0x89, 0x58, 0x20, 0x9C, 0x5B, 0x89, 0x58,
								0x24, 0x0F, 0xAE, 0x58, 0x28, 0xD9, 0x70, 0x2C, 0x8B, 0x58, 0x04, 0xB8, 0x01, 0x00, 0x00,
								0x00, 0xC3
							#endif
						#endif
					};

					static bool (*fn)(cont *) = code_init(code);

					return fn(this);
				}

				void pop() const {
					static const uint8_t code[]{
						#ifdef RUA_AMD64
							#ifdef _WIN64
								0x48, 0x8B, 0x59, 0x08, 0x48, 0x8B, 0x51, 0x18, 0x48, 0x8B, 0x71, 0x20, 0x48, 0x8B, 0x79,
								0x28, 0x48, 0x8B, 0x61, 0x30, 0x48, 0x8B, 0x69, 0x38, 0x48, 0x8B, 0x41, 0x40, 0x48, 0x89,
								0x04, 0x24, 0x48, 0x8B, 0x41, 0x48, 0x50, 0x9D, 0x4C, 0x8B, 0x41, 0x50, 0x4C, 0x8B, 0x49,
								0x58, 0x4C, 0x8B, 0x59, 0x68, 0x4C, 0x8B, 0x61, 0x70, 0x4C, 0x8B, 0x69, 0x78, 0x4C, 0x8B,
								0xB1, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xB9, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x51,
								0x18, 0x0F, 0xAE, 0x91, 0x90, 0x00, 0x00, 0x00, 0xD9, 0xA1, 0x94, 0x00, 0x00, 0x00, 0x48,
								0xC7, 0xC0, 0x30, 0x00, 0x00, 0x00, 0x65, 0x4C, 0x8B, 0x10, 0x48, 0x8B, 0x81, 0xB0, 0x00,
								0x00, 0x00, 0x49, 0x89, 0x42, 0x20, 0x48, 0x8B, 0x81, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x89,
								0x82, 0x78, 0x14, 0x00, 0x00, 0x48, 0x8B, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x49, 0x89, 0x42,
								0x10, 0x48, 0x8B, 0x81, 0xC8, 0x00, 0x00, 0x00, 0x49, 0x89, 0x42, 0x08, 0x48, 0x8B, 0x81,
								0xD0, 0x00, 0x00, 0x00, 0x49, 0x89, 0x02, 0x4C, 0x8B, 0x51, 0x60, 0x48, 0x8B, 0x49, 0x10,
								0x48, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC3
							#else
								0x48, 0x8B, 0x5F, 0x08, 0x48, 0x8B, 0x4F, 0x10, 0x48, 0x8B, 0x57, 0x18, 0x48, 0x8B, 0x77,
								0x20, 0x48, 0x8B, 0x67, 0x30, 0x48, 0x8B, 0x6F, 0x38, 0x48, 0x8B, 0x47, 0x40, 0x48, 0x89,
								0x04, 0x24, 0x48, 0x8B, 0x47, 0x48, 0x50, 0x9D, 0x4C, 0x8B, 0x47, 0x50, 0x4C, 0x8B, 0x4F,
								0x58, 0x4C, 0x8B, 0x57, 0x60, 0x4C, 0x8B, 0x5F, 0x68, 0x4C, 0x8B, 0x67, 0x70, 0x4C, 0x8B,
								0x6F, 0x78, 0x4C, 0x8B, 0xB7, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xBF, 0x88, 0x00, 0x00,
								0x00, 0x48, 0x8B, 0x57, 0x18, 0x0F, 0xAE, 0x97, 0x90, 0x00, 0x00, 0x00, 0xD9, 0xA7, 0x94,
								0x00, 0x00, 0x00, 0x48, 0x8B, 0x7F, 0x28, 0x48, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC3
							#endif
						#elif defined(RUA_I386)
							#ifdef _WIN32
								0x8B, 0x44, 0x24, 0x04, 0x8B, 0x50, 0x0C, 0x8B, 0x70, 0x10, 0x8B, 0x78, 0x14, 0x8B, 0x60,
								0x18, 0x8B, 0x68, 0x1C, 0x8B, 0x58, 0x20, 0x89, 0x1C, 0x24, 0x8B, 0x58, 0x24, 0x53, 0x9D,
								0x0F, 0xAE, 0x50, 0x28, 0xD9, 0x60, 0x2C, 0xBB, 0x18, 0x00, 0x00, 0x00, 0x64, 0x8B, 0x0B,
								0x8B, 0x58, 0x48, 0x89, 0x59, 0x10, 0x8B, 0x58, 0x4C, 0x89, 0x99, 0x0C, 0x0E, 0x00, 0x00,
								0x8B, 0x58, 0x50, 0x89, 0x59, 0x08, 0x8B, 0x58, 0x54, 0x89, 0x59, 0x04, 0x8B, 0x58, 0x58,
								0x89, 0x19, 0x8B, 0x48, 0x08, 0x8B, 0x58, 0x04, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3
							#else
								0x8B, 0x44, 0x24, 0x04, 0x8B, 0x48, 0x08, 0x8B, 0x50, 0x0C, 0x8B, 0x70, 0x10, 0x8B, 0x78,
								0x14, 0x8B, 0x60, 0x18, 0x8B, 0x68, 0x1C, 0x8B, 0x58, 0x20, 0x89, 0x1C, 0x24, 0x8B, 0x58,
								0x24, 0x53, 0x9D, 0x0F, 0xAE, 0x50, 0x28, 0xD9, 0x60, 0x2C, 0x8B, 0x58, 0x04, 0xB8, 0x00,
								0x00, 0x00, 0x00, 0xC3
							#endif
						#endif
					};

					static bool (*fn)(const cont *) = code_init(code);

					fn(this);
				}

				void push_and_pop(const cont &pre_pop) {
					if (push()) {
						pre_pop.pop();
					}
				}

				void swap() {
					auto old = *this;
					if (push()) {
						old.pop();
					}
				}

				void rebind(void (*func)(any_word), any_word func_param, any_ptr stack, size_t stack_size) {
					mctx.sp = (stack + stack_size - 4 * sizeof(uintptr_t)).value();
					mctx.caller_param() = func_param;
					mctx.caller_ip = reinterpret_cast<uintptr_t>(func);

					#ifdef _WIN32
						osctx.stack_base = stack + stack_size - 1;
						osctx.stack_limit = stack;
					#endif
				}

				void remake(void (*func)(any_word), any_word func_param, any_ptr stack, size_t stack_size) {
					push();
					rebind(func, func_param, stack, stack_size);
				}

				////////////////////////////////////////////////////////////////

				struct mctx_t {
					#if defined(RUA_AMD64) || defined(RUA_I386)
						uintptr_t a; // 0
						uintptr_t b; // 4, 8
						uintptr_t c; // 8, 16
						uintptr_t d; // 12, 24
						uintptr_t si; // 16, 32
						uintptr_t di; // 20, 40
						uintptr_t sp; // 24, 48
						uintptr_t bp; // 28, 56
						uintptr_t caller_ip; // 32, 64
						uintptr_t flags; // 36, 72

						#ifdef RUA_AMD64
							uintptr_t r8; // 80
							uintptr_t r9; // 88
							uintptr_t r10; // 96
							uintptr_t r11; // 104
							uintptr_t r12; // 112
							uintptr_t r13; // 120
							uintptr_t r14; // 128
							uintptr_t r15; // 136

							uintptr_t &caller_param() {
								return
									#ifdef RUA_WIN64_FASTCALL
										c
									#else
										di
									#endif
								;
							}

							uintptr_t caller_param() const {
								return
									#ifdef RUA_WIN64_FASTCALL
										c
									#else
										d
									#endif
								;
							}
						#endif

						#ifdef RUA_I386
							uintptr_t &caller_param() {
								return reinterpret_cast<uintptr_t *>(sp)[2];
							}

							uintptr_t caller_param() const {
								return reinterpret_cast<const uintptr_t *>(sp)[2];
							}
						#endif

						uint32_t mxcsr; // 40, 144
						uint8_t fenv[28]; // 44, 148
					#endif
				} mctx;

				#ifdef _WIN32
					struct osctx_t {
						uintptr_t fls; // 72, 176
						uintptr_t deallocation_stack; // 76, 184
						uintptr_t stack_limit; // 80, 192
						uintptr_t stack_base; // 84, 200
						uintptr_t exception_list; // 88, 208
					} osctx;
				#endif
		};

		#ifdef _WIN32
			#ifdef RUA_AMD64
				RUA_STATIC_ASSERT(offsetof(cont, osctx) == 176);
			#endif

			#ifdef RUA_I386
				RUA_STATIC_ASSERT(offsetof(cont, osctx) == 72);
			#endif
		#endif
	}
}

#endif
